import math
sum=sfix(0)
#Esto leerlo de la primera fila del .txt:
#n=sfix.load_sint(sint.get_private_input_from(0))
n=17482
print_ln('n es %s',n.reveal())

#Las n primeras corresponden al tiempo
tiempo = sfix.Array(n)
#tiempo = sfix.Array(1)

#Las n ultimas corresponden al goteo
#goteo = sfix.Array(n)
goteo = sfix.Array(1)

@for_range(1,n+1)
def setTiempo(i):
  tiempo[i] = sfix.load_sint(sint.get_private_input_from(0))

@for_range(n+1,2*n+1)
def setGoteo(i):
  goteo[i-n] = sfix.load_sint(sint.get_private_input_from(0))



#CALCULAR TIEMPO MEDIO ENTRE FALLAS:


#F numero de fallas
tiempos_fallos=sfix.Array(1)
fallas=sfix.Array(1)
start=sfix.Array(1)
start[0]=sfix(-1)

print_ln('\n \n \n SOLUCION: \n')


@for_range(n)
def range_body(i):
  #si goteo no es 0
  #empieza el goteo 
  @if_e((goteo[i]==0).reveal()==0)
  def block():
      @if_e((start[0]==-1).reveal()==1)
      def block():
          #solo tenmeos que contar la misma falla una vez
          fallas[0]=fallas[0]+1
          start[0]=i
          print_ln('\n los tiempos de inicio son: %s',tiempo[i].reveal())
          tiempos_fallos[0]=tiempos_fallos[0]+tiempo[i]
      @else_
      def block():
          fallas[0]=fallas[0]
  #Si goteo es cero
  @else_
  def block():
      start[0]=sfix(-1)


print_ln('\n Numero de fallas es: %s', fallas[0].reveal())
print_ln('\n Suma de tiempos de fallos es: %s', tiempos_fallos[0].reveal())


MTBF= tiempos_fallos[0]/fallas[0]
print_ln('\n Tiempo medio esperado hasta que tiene lugar el primer fallo es: %s ', MTBF.reveal())
#Mide la fiabilidad de los elementos no reparables.
#Corresponde al tiempo medio esperado hasta que tiene lugar el primer fallo


#Distribucion de supervivencia parametrica exponencial
#Si aplicamos esto estamos asumiendo riesgo constante

landa=sfix(1)/MTBF
print_ln('\n Valor landa de la exponencial es %s ', landa.reveal())

#funcion hazard constante
#h(t)=landa

#funcion hazard acumulada
#H(t)=landa*t

#funcion de supervivencia
#S(t)=e**(-landa*t)

#funcion de densidad
#f(t)=lambda*e**(-landa*t)


#Como la exponencial es una funcion sesgada a la derecha, la media no es una buena 
#medida de tendencia central, en su lugar es mejor utilizar la mediana:

#t=log(2)/landa

#Esto creo que es cuando tenemos varias maquinas que pueden fallar
mediana=sfix(math.log(2,10))/landa
print_ln('\n Mediana es: %s ', mediana.reveal())



#INTERPRETACION DE LOS RESULTADOS:
#       exp(-beta)=lambda
#       http://publicaciones.san.gva.es/publicaciones/documentos/Quaderns_11V.2405-1997.pdf
#       contraste de Wald: Contrasta la hipotesis nula beta=0
#           Compara el cuadrado del cociente entre beta y su error estandar con una X^2 con 1 grado de libertad
#           Si el resultado es sifnificativo indicara que la tasa de peligro constante es distinta de cero


#OTRAS COSAS QUE SE PUEDEN CALCULAR:

# 1- La fiabilidad de la maquina para un periodo de 100h de funcionamiento. 
#Es decir, la probabilidad de que la maquina sobreviva 100h.
#Como el tiempo esta dado en minutos 100*60=6000


#Esto cambiarlo a la exponencial de verdad. Creo que solo se puede hacer 2^secret
e = sfix(2.718281)

#S_6000=sfix(mpc_math.pow(e,-landa*6000))
#S_6000=S_6000*sfix(100)

#print_ln('Probabilidad de que la maquina sobreviva 100h: %s %',S_6000.reveal())