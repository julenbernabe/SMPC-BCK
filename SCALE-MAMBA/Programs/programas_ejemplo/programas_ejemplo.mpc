# En el github de SPDZ-2: tpmpc_tutorial.mpc
#https://github.com/bristolcrypto/SPDZ-2/blob/master/Programs/Source/tpmpc_tutorial.mpc


#Adaptado para la lectura de ficheros:

from util import if_else

#program.bit_length = 32

#-------------------------FUNCTION MILLONNARIES------------------
#Cuando tenemos dos partes, Alice y Bob, y queremos saber cual de los dos tiene mas dinero
#El problema de los millonarios nos dice simplemente si alice tiene menos dinero que bob
##Se lee el dinero de cada participante de su .txt


def millionnaires():
    alice= sint.get_private_input_from(0)

    bob= sint.get_private_input_from(1)
    
    b = alice < bob
    
    print_ln('Bob es mas rico que Alice: %s', b.reveal())

#Suponiendo que alice tiene 2000000 y Bob tiene 3000000:
#millionnaires() #1

#Suponiendo que alice tiene 4000000 y Bob tiene 3000000:
#millionnaires() #0


#---------------------FUNCTION naive_search-----------------
#Teniendo una lista de valores secretos busca el input que le mete Bob

# hardcoded "secret" list from Alice
n=10
'''
lista= []
for i in range(n):
    elem=sint.get_private_input_from(0)
    lista.append(elem)

def naive_search(lista):

	b = sint.get_private_input_from(1)
    

	eq_bits = [x == b for x in lista]

	b_in_lista = sum(eq_bits)

	print_ln("Esta el numero de Bob en la lista de Alice? %s", b_in_lista.reveal())
'''

#Si la lista de Alice es 1,2,3,4,5,6,7,8,9,10
#Y el numero de Bob es 11 no esta 
#naive_search(lista) #0

#Si el numero de Bob es 4 si esta 
#naive_search(lista) #1


#--------------------FUNCTION scalable_search------------------------

#Las n primeras corresponden al tiempo
n=10
lista2 = sint.Array(n)
    
@for_range(n)
def setLista2(j):
    elem=sint.get_private_input_from(0)
    lista2[j] = elem


def scalable_search(lista2):
    b=sint.get_private_input_from(1)
    result=MemValue(sint(0))
    @for_range(n)
    def range_body(i):
        result.write(result+(lista2[i] == b))
    print_ln('Esta el numero de Bob en la lista de Alice? %s', result.reveal())

#Si la lista de Alice es 1,2,3,4,5,6,7,8,9,10
#Y el numero de Bob es 11 no esta 
#scalable_search(lista2) #0

#Si el numero de Bob es 4 si esta 
#scalable_search(lista2) #1


#-------------------FUNCTION compute_intersectiona(a,b)------------------
#Naive quadratic private set intersection
#Te devuelve: un Array con la interseccion (padded to len(a))
#             un Array de bits indicando si el input de Alice coincide o no

def compute_intersection(a, b):

	n = len(a)
	if n != len(b):
		raise CompilerError('Inconsistent lengths to compute_intersection')
	intersection = Array(n, sint)
	is_match_at = Array(n, sint)

	@for_range(n)
	def _(i):
		@for_range(n)
		def _(j):
			match = a[i] == b[j]
			is_match_at[i] += match
			intersection[i] = if_else(match, a[i], intersection[i]) # match * a[i] + (1 - match) * intersection[i]
	return intersection, is_match_at

#Si la lista de Alice es 1,2,3,4,5,6,7,8,9,10
#Y la lista de Bob es 1,2,12
#Compiler.exceptions.CompilerError: Inconsistent lengths to compute_intersection

#Si la lista de Bob es 1,2,12,4,5,13,11,8,9,10
''''
lista3 = sint.Array(n)
@for_range(n)
def setLista3(j):
    elem=sint.get_private_input_from(1)
    lista3[j] = elem

intersection=compute_intersection(lista2, lista3)[0]
match_list=compute_intersection(lista2, lista3)[1]

for i in range(n):
    print_ln('Intersection: %s',intersection[i].reveal())

for i in range(n):
    print_ln('Match: %s',match_list[i].reveal())

#Intersection: 1 2 0 4 5 0 0 8 9 10
#Match:        1 1 0 1 1 0 0 1 1 1
'''

def set_intersection_example(n):
    a= sint.Array(n)
    b= sint.Array(n)
    print_ln('Running PSI example')
    @for_range(n)
    def _(i):
        a[i] = i
        b[i] = i+2
    intersection, is_match_at = compute_intersection(a,b)
    print_ln('Printing set intersection (0: no in intersection)')
    size = MemValue(sint(0))
    total = MemValue(sint(0))
    @for_range(n)
    def _(i):
        size.write(size + is_match_at[i])
        total.write(total + intersection[i])
        print_str('%s ', intersection[i].reveal()) #Asi se imprime todo el vector en una linea
    print_ln('\nIntersection size: %s', size.reveal())

    total_fixed = sfix()
    total_fixed.load_int(total.read())
    print_ln('Average in intersection: %s', (total_fixed / size.read()).reveal())



set_intersection_example(10)
#a: 1 2 3 4 5 6 7 8 9 10
#b: 3 4 5 6 7 8 9 19 11 12