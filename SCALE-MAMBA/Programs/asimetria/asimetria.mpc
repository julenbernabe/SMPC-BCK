#Para ver cuan simetrica es la distribucion de una variable respecto a su media sin necesidad de representarla graficamente,
#empleamos el coeficiente de asimetria de Fisher C.

#Si C<0, entonces la distribucion es asimetrica negativa (el pico esta mas a la derecha que la media). Si C=0, entonces
#la distribucion es simetrica (el pico y la media coinciden). Si C>0, entonces la distribucion es asimetrica positiva (el pico
#esta mas a la izquierda que la media).

#El coeficiente C se calcula mediante la formula:

#                                       C=sumatorio(x_i-media)**3/(N*S**3)

#donde x_i en (x_1,...,x_N) son los valores de la muestra y S es la desviacion tipica.

#En este programa, los player 1 y 2 introducen 4 datos y el player 3 introduce 5.

n0 = 4
n1 = 4
n2 = 5

#Hallamos N lo primero. Lo guardamos como sfix porque lo necesitaremos para las divisiones mas adelante, y si no dara errores.

N = sfix(n0 + n1 + n2)

#Creamos vectores con los valores que introduce cada uno, para luego poder leerlos en el porgrama. Los creamos en secreto.

v0 = sfix.Array(n0)
v1 = sfix.Array(n1)
v2 = sfix.Array(n2)

#Y ahora leemos los inputs de los players en estos vectores.

@for_range(n0)
def leerv0(i):
  v0[i] = sfix.load_sint(sint.get_private_input_from(0))

@for_range(n1)
def leerv1(i):
  v1[i] = sfix.load_sint(sint.get_private_input_from(1))

@for_range(n2)
def leerv2(i):
  v2[i] = sfix.load_sint(sint.get_private_input_from(2))

#Ahora que ya tenemos cargados los datos, vamos calculando los estadisticos.

#MEDIA:

m = sfix(0)
s1 = sfix(0)

#En s1 guardamos la suma de todos los valores de la muestra. Lo guardamos como sfix para poder luego hallar la media.
#Ahora vamos sumando todos los valores en s:

for i in range (n0):
    s1 = s1 + v0[i]

for i in range (n1):
    s1 = s1 + v1[i]

for i in range (n2):
    s1 = s1 + v2[i]

#Calculamos la media:

m = s1/N

#DESVIACION TIPICA:

#Para la desviacion tipica S, necesitaremos hacer una raiz cuadrada. Por ello, importamos el paquete math.

import math

#En la variable S guardaremos la desviacion tipica. En s2 todos los cuadrados para calcular S.
#El coeficiente C de asimetria de Fisher
S = sfix(0)
s2 = sfix(0)

for i in range (n0):
    s2 = s2 + (v0[i] - m)**2

for i in range (n1):
    s2 = s2 + (v1[i] - m)**2

for i in range (n2):
    s2 = s2 + (v2[i] - m)**2

S = mpc_math.sqrt(s2/N)

#COEFICIENTE DE ASIMETRIA DE FISHER:

#El coeficiente se guardara en la variable C. En s3 guardamos los cubos al igual que antes hemos guardado los cuadrados.

C = sfix(0)
s3 = sfix(0)

for i in range (n0):
    s3 = s3 + (v0[i] - m)*(v0[i] - m)*(v0[i] - m)

for i in range (n1):
    s3 = s3 + (v1[i] - m)*(v1[i] - m)*(v1[i] - m)

for i in range (n2):
    s3 = s3 + (v2[i] - m)*(v2[i] - m)*(v2[i] - m)

#En S3 guardamos S**3:

S3 = S * S * S

#La variable X guardara el valor N*S3, que es el denominador de C.

X = N * S3

C = s3/X

print_ln('\n\nSOLUCION:\n\n')

#Por ultimo, describimos los tipos de asimetria que tenemos con los if siguientes:

@if_e((C==0).reveal()==1)
def block():
    print_ln('La distribucion de los datos es simetrica.')
@else_
def block():
    @if_e((C>0).reveal()==1)
    def block():
        print_ln('La distribucion de los datos es simetrica positiva.')
    @else_
    def block():
        print_ln('La distribucion de los datos es simetrica negativa.')

<<<<<<< HEAD
print_ln('\n\nEl coeficiente C de asimetria de Fisher del conjunto de datos es: %s\n\n', C.reveal())
=======
print_ln('\n\nEl coeficiente C de asimetria de Fisher del conjunto de datos es: %s\n\n', C.reveal())
>>>>>>> develop
