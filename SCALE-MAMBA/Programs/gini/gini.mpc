#Inidice de impureza de gini

#gini=sumatorio pk(1-pk)
#   pk es la proporcion 

#Cuidado, impureza de gini no es lo mismo que coeficiente de gini
#IMPUREZA DE GINI 
#   Utilizado por el algoritmo de ACR (Arboles de Clasificacion y Regresion)
#   se puede calcular sumando la probabilidad de cada elemento siendo elegido multiplicado por la probabilidad de un error en la categorizacion de ese elemento
#   Metrica estandar de division de arboles de decision
#   Es lo que se usa comunmente en los arboles de decision    
#COEFICIENTE DE GINI
#   Cada division se puede evaluar en funcion del critero auc
#   Para cada escenario de divisi√≥n, podemos construir una curva ROC y calcular la metrica AUC. Segun Wikipedia AUC = (GiniCoeff + 1) / 2;


#CALCULAR GINI IMPURITY
#   https://victorzhou.com/blog/gini-impurity/
#   Se escoge un punto random de los datos
#   De forma random se clasifica de acuerdo a la distribucion de clases de los datos
#   Cual es la probabilidad de haberlo clasificado de forma incorrecta? La respuesta es la impureza de gini
#Si tenemos C clases en total y p(i) es la probabilidad de clasificar un punto en la clase i:
# G= sumatorio(i=1,...,C) p(i) (1-p(i)) 

#La impureza de gini esta implementado en decision_tree


#----------------------------------------- FUNCION gini ------------------------------------------
#Sirve para calcular la impureza de gini
#Como de frecuente es que un elemento elegido de forma random sea clasificado incorrectamente
    #si se elige el tipo de forma random, es decir, si tienes un bol con naranjas, mandarinas y manzanas
    #y otro bol con papeles en los que pone naranja, mandarina o manzana
    #Se elige de cada bol un elemento de forma random.
    #La frecuencia de que no coincida se mide con la impureza de gini.
#formula sacada de : https://en.wikipedia.org/wiki/Decision_tree_learning#Gini_impurity

#En realidad, no tendremos una lista con el data dividido, por lo que hay la funcion de gini toma el data entero 
#y la lista partition_list que le indica como esta dividido para dividirlo dentro de la funcion 

#Input:
#   data: una matriz donde las primeras columnas corresponden a la X y la ultima columna es la variable cualitativa Yellow
#   valores_y: todos los valores que puede tomar la variable cualitativa y
#   partition_list: una lista donde cada indice de la lista indica la fila a la que se refiere y el numero corresponde al nodo al que pertenece esa fila

def gini(data,valores_y,partition_list,nodo):
    
    #Numero de categorias de la variable y
    #pero puede que las m no esten en el subdata que estamos mirando
    m=len(valores_y) 

    #En counts lo que tenemos que guardar es por cada tipo diferente de ultima variable cuantos hay
    #En caso de que ese variable no este en nuestro conjunto sera cero 
    #Si es cero no influye porque p_i sera 0 y no se le resta nada a gini
    counts=sfix.Array(m) 
    
    #Guadamos en una variable el numero de elementos de ese nodo:
    q=sfix.Array(1)
    q[0]=sfix(0)

    #Miramos de entre todas las filas del data las que estan en nuestro nodo
    @for_range(len(data))
    def range_body(i):
        #Miramos los que en la partition_list tengan justo ese numero de nodo
        @if_e((partition_list[i]==nodo).reveal()==1)
        def block():
            #Sumamos uno al numero de elementos de ese nodo:
            q[0]=q[0]+1
            #Cogemos el valor que toma esta fila en la variable Y
            label=data[i][-1]

            #Ahora miramos cual de todas las m posibilidades de Y es y le sumamos uno:
            @for_range(m)
            def range_body(j):
                categoria=valores_y[j]

                #Si el valor de label es igual al de la categoria sumamos counts[j]+1
                @if_e((label==categoria).reveal()==1)
                def block():
                    counts[j]=counts[j]+1
                @else_
                def block():
                    counts[j]=counts[j]
        @else_
        def block():
            nada=0
            #no hacemos nada
 
    
    #La formula es:
    #I=1- sum(i=1,2,...,m)p_i^2
    #suponiendo que m es el numero de clases y p_i la fraccion de items clasificados como clase i
    
    impurity=sfix.Array(1)
    impurity[0]=sfix(1)

    @for_range(m)
    def range_body(i):
        p_i = counts[i] / q[0]
        impurity[0] =impurity[0] - p_i*p_i

    return impurity[0]